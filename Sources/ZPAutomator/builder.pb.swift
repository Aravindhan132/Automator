// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: builder.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum ZPScreenType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case list // = 0
  case grid // = 1
  case detail // = 2
  case reply // = 3
  case editList // = 4
  case chat // = 5
  case actionSheet // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .list
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .list
    case 1: self = .grid
    case 2: self = .detail
    case 3: self = .reply
    case 4: self = .editList
    case 5: self = .chat
    case 6: self = .actionSheet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .list: return 0
    case .grid: return 1
    case .detail: return 2
    case .reply: return 3
    case .editList: return 4
    case .chat: return 5
    case .actionSheet: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ZPScreenType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPScreenType] = [
    .list,
    .grid,
    .detail,
    .reply,
    .editList,
    .chat,
    .actionSheet,
  ]
}

#endif  // swift(>=4.2)

enum ZPDirection: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case horizontal // = 0
  case vertical // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .horizontal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .horizontal
    case 1: self = .vertical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .horizontal: return 0
    case .vertical: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ZPDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPDirection] = [
    .horizontal,
    .vertical,
  ]
}

#endif  // swift(>=4.2)

enum ZPActionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case passOn // = 1
  case tap // = 2
  case longPress // = 3
  case leftSwipe // = 4
  case rightSwipe // = 5
  case doubleTap // = 6
  case onTextChange // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .passOn
    case 2: self = .tap
    case 3: self = .longPress
    case 4: self = .leftSwipe
    case 5: self = .rightSwipe
    case 6: self = .doubleTap
    case 7: self = .onTextChange
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .passOn: return 1
    case .tap: return 2
    case .longPress: return 3
    case .leftSwipe: return 4
    case .rightSwipe: return 5
    case .doubleTap: return 6
    case .onTextChange: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ZPActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPActionType] = [
    .none,
    .passOn,
    .tap,
    .longPress,
    .leftSwipe,
    .rightSwipe,
    .doubleTap,
    .onTextChange,
  ]
}

#endif  // swift(>=4.2)

enum ZPItemType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case hStack // = 0
  case vStack // = 1
  case zStack // = 2
  case label // = 3
  case button // = 4
  case textInput // = 5
  case textView // = 6
  case iconView // = 7
  case imageView // = 8
  case seperatorView // = 9
  case webView // = 10
  case scrollView // = 11
  case gridView // = 12
  case chipView // = 13
  case popUpView // = 14
  case progressView // = 15
  case checkBoxView // = 16
  case chartView // = 17
  case tabLayoutViewPager // = 18
  case pagingView // = 19
  case page // = 20
  case tabView // = 21
  case tabViewIndicator // = 22
  case listView // = 23
  case loader // = 24
  case rightBarButton // = 25
  case leftBarButton // = 26
  case UNRECOGNIZED(Int)

  init() {
    self = .hStack
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hStack
    case 1: self = .vStack
    case 2: self = .zStack
    case 3: self = .label
    case 4: self = .button
    case 5: self = .textInput
    case 6: self = .textView
    case 7: self = .iconView
    case 8: self = .imageView
    case 9: self = .seperatorView
    case 10: self = .webView
    case 11: self = .scrollView
    case 12: self = .gridView
    case 13: self = .chipView
    case 14: self = .popUpView
    case 15: self = .progressView
    case 16: self = .checkBoxView
    case 17: self = .chartView
    case 18: self = .tabLayoutViewPager
    case 19: self = .pagingView
    case 20: self = .page
    case 21: self = .tabView
    case 22: self = .tabViewIndicator
    case 23: self = .listView
    case 24: self = .loader
    case 25: self = .rightBarButton
    case 26: self = .leftBarButton
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .hStack: return 0
    case .vStack: return 1
    case .zStack: return 2
    case .label: return 3
    case .button: return 4
    case .textInput: return 5
    case .textView: return 6
    case .iconView: return 7
    case .imageView: return 8
    case .seperatorView: return 9
    case .webView: return 10
    case .scrollView: return 11
    case .gridView: return 12
    case .chipView: return 13
    case .popUpView: return 14
    case .progressView: return 15
    case .checkBoxView: return 16
    case .chartView: return 17
    case .tabLayoutViewPager: return 18
    case .pagingView: return 19
    case .page: return 20
    case .tabView: return 21
    case .tabViewIndicator: return 22
    case .listView: return 23
    case .loader: return 24
    case .rightBarButton: return 25
    case .leftBarButton: return 26
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ZPItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPItemType] = [
    .hStack,
    .vStack,
    .zStack,
    .label,
    .button,
    .textInput,
    .textView,
    .iconView,
    .imageView,
    .seperatorView,
    .webView,
    .scrollView,
    .gridView,
    .chipView,
    .popUpView,
    .progressView,
    .checkBoxView,
    .chartView,
    .tabLayoutViewPager,
    .pagingView,
    .page,
    .tabView,
    .tabViewIndicator,
    .listView,
    .loader,
    .rightBarButton,
    .leftBarButton,
  ]
}

#endif  // swift(>=4.2)

enum ZPInputType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case text // = 0
  case number // = 1
  case email // = 2
  case web // = 3
  case datePicker // = 4
  case dateTimePicker // = 5
  case picker // = 6
  case phone // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .text
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .text
    case 1: self = .number
    case 2: self = .email
    case 3: self = .web
    case 4: self = .datePicker
    case 5: self = .dateTimePicker
    case 6: self = .picker
    case 7: self = .phone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .text: return 0
    case .number: return 1
    case .email: return 2
    case .web: return 3
    case .datePicker: return 4
    case .dateTimePicker: return 5
    case .picker: return 6
    case .phone: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ZPInputType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPInputType] = [
    .text,
    .number,
    .email,
    .web,
    .datePicker,
    .dateTimePicker,
    .picker,
    .phone,
  ]
}

#endif  // swift(>=4.2)

struct ZPApp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screens: [ZPScreen] = []

  var darkColors: [ZPColorRGB] = []

  var lightColors: [ZPColorRGB] = []

  var fontStyles: [ZPFontStyle] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPScreen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Make it as UUID
  var uid: String = String()

  var module: String = String()

  var screenType: ZPScreenType = .list

  var segments: [ZPSegment] = []

  var passOnAction: ZPAction {
    get {return _passOnAction ?? ZPAction()}
    set {_passOnAction = newValue}
  }
  /// Returns true if `passOnAction` has been explicitly set.
  var hasPassOnAction: Bool {return self._passOnAction != nil}
  /// Clears the value of `passOnAction`. Subsequent reads from it will return its default value.
  mutating func clearPassOnAction() {self._passOnAction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _passOnAction: ZPAction? = nil
}

struct ZPSegment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var segmentType: ZPSegment.ZPSegmentType = .topNavigationBar

  var style: ZPItemStyle {
    get {return _style ?? ZPItemStyle()}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var segmentSizeAttribute: ZPSizeAttribute {
    get {return _segmentSizeAttribute ?? ZPSizeAttribute()}
    set {_segmentSizeAttribute = newValue}
  }
  /// Returns true if `segmentSizeAttribute` has been explicitly set.
  var hasSegmentSizeAttribute: Bool {return self._segmentSizeAttribute != nil}
  /// Clears the value of `segmentSizeAttribute`. Subsequent reads from it will return its default value.
  mutating func clearSegmentSizeAttribute() {self._segmentSizeAttribute = nil}

  var actions: [ZPAction] = []

  var patterns: [ZPItem] = []

  var isNative: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPSegmentType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case topNavigationBar // = 0
    case bottomNavigationBar // = 1
    case listHeader // = 2
    case listFooter // = 3
    case sectionHeader // = 4
    case sectionFooter // = 5
    case listItem // = 6
    case container // = 7
    case search // = 8
    case keyboardAccessoryView // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .topNavigationBar
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .topNavigationBar
      case 1: self = .bottomNavigationBar
      case 2: self = .listHeader
      case 3: self = .listFooter
      case 4: self = .sectionHeader
      case 5: self = .sectionFooter
      case 6: self = .listItem
      case 7: self = .container
      case 8: self = .search
      case 9: self = .keyboardAccessoryView
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .topNavigationBar: return 0
      case .bottomNavigationBar: return 1
      case .listHeader: return 2
      case .listFooter: return 3
      case .sectionHeader: return 4
      case .sectionFooter: return 5
      case .listItem: return 6
      case .container: return 7
      case .search: return 8
      case .keyboardAccessoryView: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _style: ZPItemStyle? = nil
  fileprivate var _segmentSizeAttribute: ZPSizeAttribute? = nil
}

#if swift(>=4.2)

extension ZPSegment.ZPSegmentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPSegment.ZPSegmentType] = [
    .topNavigationBar,
    .bottomNavigationBar,
    .listHeader,
    .listFooter,
    .sectionHeader,
    .sectionFooter,
    .listItem,
    .container,
    .search,
    .keyboardAccessoryView,
  ]
}

#endif  // swift(>=4.2)

struct ZPItemStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isHide: Bool {
    get {return _storage._isHide}
    set {_uniqueStorage()._isHide = newValue}
  }

  /// ZPColorRGB reference Id
  var bgColorID: String {
    get {return _storage._bgColorID}
    set {_uniqueStorage()._bgColorID = newValue}
  }

  var imageStyle: ZPImageStyle {
    get {return _storage._imageStyle ?? ZPImageStyle()}
    set {_uniqueStorage()._imageStyle = newValue}
  }
  /// Returns true if `imageStyle` has been explicitly set.
  var hasImageStyle: Bool {return _storage._imageStyle != nil}
  /// Clears the value of `imageStyle`. Subsequent reads from it will return its default value.
  mutating func clearImageStyle() {_uniqueStorage()._imageStyle = nil}

  var gradientStyle: ZPGradientStyle {
    get {return _storage._gradientStyle ?? ZPGradientStyle()}
    set {_uniqueStorage()._gradientStyle = newValue}
  }
  /// Returns true if `gradientStyle` has been explicitly set.
  var hasGradientStyle: Bool {return _storage._gradientStyle != nil}
  /// Clears the value of `gradientStyle`. Subsequent reads from it will return its default value.
  mutating func clearGradientStyle() {_uniqueStorage()._gradientStyle = nil}

  var shadowStyle: ZPShadowStyle {
    get {return _storage._shadowStyle ?? ZPShadowStyle()}
    set {_uniqueStorage()._shadowStyle = newValue}
  }
  /// Returns true if `shadowStyle` has been explicitly set.
  var hasShadowStyle: Bool {return _storage._shadowStyle != nil}
  /// Clears the value of `shadowStyle`. Subsequent reads from it will return its default value.
  mutating func clearShadowStyle() {_uniqueStorage()._shadowStyle = nil}

  var borderStyle: ZPBorderStyle {
    get {return _storage._borderStyle ?? ZPBorderStyle()}
    set {_uniqueStorage()._borderStyle = newValue}
  }
  /// Returns true if `borderStyle` has been explicitly set.
  var hasBorderStyle: Bool {return _storage._borderStyle != nil}
  /// Clears the value of `borderStyle`. Subsequent reads from it will return its default value.
  mutating func clearBorderStyle() {_uniqueStorage()._borderStyle = nil}

  var gridStyle: ZPGridStyle {
    get {return _storage._gridStyle ?? ZPGridStyle()}
    set {_uniqueStorage()._gridStyle = newValue}
  }
  /// Returns true if `gridStyle` has been explicitly set.
  var hasGridStyle: Bool {return _storage._gridStyle != nil}
  /// Clears the value of `gridStyle`. Subsequent reads from it will return its default value.
  mutating func clearGridStyle() {_uniqueStorage()._gridStyle = nil}

  var scrollStyle: ZPScrollStyle {
    get {return _storage._scrollStyle ?? ZPScrollStyle()}
    set {_uniqueStorage()._scrollStyle = newValue}
  }
  /// Returns true if `scrollStyle` has been explicitly set.
  var hasScrollStyle: Bool {return _storage._scrollStyle != nil}
  /// Clears the value of `scrollStyle`. Subsequent reads from it will return its default value.
  mutating func clearScrollStyle() {_uniqueStorage()._scrollStyle = nil}

  var textStyle: ZPTextStyle {
    get {return _storage._textStyle ?? ZPTextStyle()}
    set {_uniqueStorage()._textStyle = newValue}
  }
  /// Returns true if `textStyle` has been explicitly set.
  var hasTextStyle: Bool {return _storage._textStyle != nil}
  /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
  mutating func clearTextStyle() {_uniqueStorage()._textStyle = nil}

  var seperatorType: ZPItemStyle.ZPSeparatorType {
    get {return _storage._seperatorType}
    set {_uniqueStorage()._seperatorType = newValue}
  }

  var tabViewType: ZPItemStyle.ZPTabViewType {
    get {return _storage._tabViewType}
    set {_uniqueStorage()._tabViewType = newValue}
  }

  ///Need to fix
  var cornerRadius: ZPItemStyle.ZPItemCornerRadius {
    get {return _storage._cornerRadius ?? ZPItemStyle.ZPItemCornerRadius()}
    set {_uniqueStorage()._cornerRadius = newValue}
  }
  /// Returns true if `cornerRadius` has been explicitly set.
  var hasCornerRadius: Bool {return _storage._cornerRadius != nil}
  /// Clears the value of `cornerRadius`. Subsequent reads from it will return its default value.
  mutating func clearCornerRadius() {_uniqueStorage()._cornerRadius = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPSeparatorType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case line // = 0
    case dot // = 1
    case space // = 2
    case dashed // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .line
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .line
      case 1: self = .dot
      case 2: self = .space
      case 3: self = .dashed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .line: return 0
      case .dot: return 1
      case .space: return 2
      case .dashed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum ZPTabViewType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case segment // = 0
    case tab // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .segment
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .segment
      case 1: self = .tab
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .segment: return 0
      case .tab: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct ZPItemCornerRadius {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var all: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _all ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_all = newValue}
    }
    /// Returns true if `all` has been explicitly set.
    var hasAll: Bool {return self._all != nil}
    /// Clears the value of `all`. Subsequent reads from it will return its default value.
    mutating func clearAll() {self._all = nil}

    var topLeft: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _topLeft ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_topLeft = newValue}
    }
    /// Returns true if `topLeft` has been explicitly set.
    var hasTopLeft: Bool {return self._topLeft != nil}
    /// Clears the value of `topLeft`. Subsequent reads from it will return its default value.
    mutating func clearTopLeft() {self._topLeft = nil}

    var topRight: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _topRight ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_topRight = newValue}
    }
    /// Returns true if `topRight` has been explicitly set.
    var hasTopRight: Bool {return self._topRight != nil}
    /// Clears the value of `topRight`. Subsequent reads from it will return its default value.
    mutating func clearTopRight() {self._topRight = nil}

    var bottomLeft: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _bottomLeft ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_bottomLeft = newValue}
    }
    /// Returns true if `bottomLeft` has been explicitly set.
    var hasBottomLeft: Bool {return self._bottomLeft != nil}
    /// Clears the value of `bottomLeft`. Subsequent reads from it will return its default value.
    mutating func clearBottomLeft() {self._bottomLeft = nil}

    var bottomRight: SwiftProtobuf.Google_Protobuf_FloatValue {
      get {return _bottomRight ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
      set {_bottomRight = newValue}
    }
    /// Returns true if `bottomRight` has been explicitly set.
    var hasBottomRight: Bool {return self._bottomRight != nil}
    /// Clears the value of `bottomRight`. Subsequent reads from it will return its default value.
    mutating func clearBottomRight() {self._bottomRight = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _all: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    fileprivate var _topLeft: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    fileprivate var _topRight: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    fileprivate var _bottomLeft: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    fileprivate var _bottomRight: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ZPItemStyle.ZPSeparatorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPItemStyle.ZPSeparatorType] = [
    .line,
    .dot,
    .space,
    .dashed,
  ]
}

extension ZPItemStyle.ZPTabViewType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPItemStyle.ZPTabViewType] = [
    .segment,
    .tab,
  ]
}

#endif  // swift(>=4.2)

struct ZPImageStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imagePath: String = String()

  var fetchType: ZPImageStyle.ZPImageFetchType = .urlType

  var contentType: ZPImageStyle.ZPImageContentType = .fill

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPImageFetchType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case urlType // = 0
    case stream // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .urlType
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .urlType
      case 1: self = .stream
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .urlType: return 0
      case .stream: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum ZPImageContentType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case fill // = 0

    ///aspectFill /* content is scaled to maintain its aspect ratio */
    case contain // = 1

    ///aspectFit /* content is sized to maintain its aspect ratio */
    case cover // = 2
    case center // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .fill
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fill
      case 1: self = .contain
      case 2: self = .cover
      case 3: self = .center
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .fill: return 0
      case .contain: return 1
      case .cover: return 2
      case .center: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ZPImageStyle.ZPImageFetchType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPImageStyle.ZPImageFetchType] = [
    .urlType,
    .stream,
  ]
}

extension ZPImageStyle.ZPImageContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPImageStyle.ZPImageContentType] = [
    .fill,
    .contain,
    .cover,
    .center,
  ]
}

#endif  // swift(>=4.2)

struct ZPGradientStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ZPColorRGB reference Id
  var colorID: [String] = []

  var direction: ZPDirection = .horizontal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPShadowStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Need to update
  var shadowColorID: String = String()

  var shadowRadius: Int32 = 0

  var shadowOpacity: Float = 0

  var offset: ZPShadowStyle.ZPShadowOffset {
    get {return _offset ?? ZPShadowStyle.ZPShadowOffset()}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ZPShadowOffset {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: Int32 = 0

    var height: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _offset: ZPShadowStyle.ZPShadowOffset? = nil
}

struct ZPBorderStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Need to update
  var borderColorID: String = String()

  var borderWidth: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPGridStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isDraggable: Bool = false

  var gridColoumnCount: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _gridColoumnCount ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_gridColoumnCount = newValue}
  }
  /// Returns true if `gridColoumnCount` has been explicitly set.
  var hasGridColoumnCount: Bool {return self._gridColoumnCount != nil}
  /// Clears the value of `gridColoumnCount`. Subsequent reads from it will return its default value.
  mutating func clearGridColoumnCount() {self._gridColoumnCount = nil}

  var direction: ZPDirection = .horizontal

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gridColoumnCount: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
}

struct ZPScrollStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isShowHorizontalScrollIndicator: Bool = false

  var isShowVerticalScrollIndicator: Bool = false

  var isScrollEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPTextStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fontStyleID: String = String()

  var isEditable: Bool = false

  var maxLines: Int32 = 0

  var alignment: ZPTextStyle.ZPTextAlignment = .left

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPTextAlignment: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case left // = 0
    case right // = 1
    case top // = 2
    case bottom // = 3
    case center // = 4
    case justified // = 5
    case natural // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .left
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .left
      case 1: self = .right
      case 2: self = .top
      case 3: self = .bottom
      case 4: self = .center
      case 5: self = .justified
      case 6: self = .natural
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .left: return 0
      case .right: return 1
      case .top: return 2
      case .bottom: return 3
      case .center: return 4
      case .justified: return 5
      case .natural: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ZPTextStyle.ZPTextAlignment: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPTextStyle.ZPTextAlignment] = [
    .left,
    .right,
    .top,
    .bottom,
    .center,
    .justified,
    .natural,
  ]
}

#endif  // swift(>=4.2)

struct ZPSizeAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: ZPSize {
    get {return _storage._width ?? ZPSize()}
    set {_uniqueStorage()._width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return _storage._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {_uniqueStorage()._width = nil}

  var height: ZPSize {
    get {return _storage._height ?? ZPSize()}
    set {_uniqueStorage()._height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return _storage._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {_uniqueStorage()._height = nil}

  var minWidth: ZPSize {
    get {return _storage._minWidth ?? ZPSize()}
    set {_uniqueStorage()._minWidth = newValue}
  }
  /// Returns true if `minWidth` has been explicitly set.
  var hasMinWidth: Bool {return _storage._minWidth != nil}
  /// Clears the value of `minWidth`. Subsequent reads from it will return its default value.
  mutating func clearMinWidth() {_uniqueStorage()._minWidth = nil}

  var huggingPriority: String {
    get {return _storage._huggingPriority}
    set {_uniqueStorage()._huggingPriority = newValue}
  }

  var resistentPriority: String {
    get {return _storage._resistentPriority}
    set {_uniqueStorage()._resistentPriority = newValue}
  }

  var depency: ZPDependency {
    get {return _storage._depency ?? ZPDependency()}
    set {_uniqueStorage()._depency = newValue}
  }
  /// Returns true if `depency` has been explicitly set.
  var hasDepency: Bool {return _storage._depency != nil}
  /// Clears the value of `depency`. Subsequent reads from it will return its default value.
  mutating func clearDepency() {_uniqueStorage()._depency = nil}

  var padding: ZPPadding {
    get {return _storage._padding ?? ZPPadding()}
    set {_uniqueStorage()._padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return _storage._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {_uniqueStorage()._padding = nil}

  var position: ZPSizeAttribute.ZPZStackPosition {
    get {return _storage._position}
    set {_uniqueStorage()._position = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPZStackPosition: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case center // = 1
    case topLeft // = 2
    case topRight // = 3
    case bottomLeft // = 4
    case bottomRight // = 5
    case topCenter // = 6
    case bottomCenter // = 7
    case leftCenter // = 8
    case rightCenter // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .center
      case 2: self = .topLeft
      case 3: self = .topRight
      case 4: self = .bottomLeft
      case 5: self = .bottomRight
      case 6: self = .topCenter
      case 7: self = .bottomCenter
      case 8: self = .leftCenter
      case 9: self = .rightCenter
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .center: return 1
      case .topLeft: return 2
      case .topRight: return 3
      case .bottomLeft: return 4
      case .bottomRight: return 5
      case .topCenter: return 6
      case .bottomCenter: return 7
      case .leftCenter: return 8
      case .rightCenter: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension ZPSizeAttribute.ZPZStackPosition: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPSizeAttribute.ZPZStackPosition] = [
    .none,
    .center,
    .topLeft,
    .topRight,
    .bottomLeft,
    .bottomRight,
    .topCenter,
    .bottomCenter,
    .leftCenter,
    .rightCenter,
  ]
}

#endif  // swift(>=4.2)

struct ZPSize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valueType: ZPSize.ZPSizeValueType = .none

  var value: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPSizeValueType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0

    ///parentPartitionSize (value should be within 0 to 100)
    case stretchToParent // = 1

    ///dynamicSize
    case wrapContent // = 2

    ///staticWidth
    case staticValue // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .stretchToParent
      case 2: self = .wrapContent
      case 3: self = .staticValue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .stretchToParent: return 1
      case .wrapContent: return 2
      case .staticValue: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ZPSize.ZPSizeValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPSize.ZPSizeValueType] = [
    .none,
    .stretchToParent,
    .wrapContent,
    .staticValue,
  ]
}

#endif  // swift(>=4.2)

struct ZPPadding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var top: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _top ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_top = newValue}
  }
  /// Returns true if `top` has been explicitly set.
  var hasTop: Bool {return self._top != nil}
  /// Clears the value of `top`. Subsequent reads from it will return its default value.
  mutating func clearTop() {self._top = nil}

  var bottom: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _bottom ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_bottom = newValue}
  }
  /// Returns true if `bottom` has been explicitly set.
  var hasBottom: Bool {return self._bottom != nil}
  /// Clears the value of `bottom`. Subsequent reads from it will return its default value.
  mutating func clearBottom() {self._bottom = nil}

  var left: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _left ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return self._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {self._left = nil}

  var right: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _right ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return self._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {self._right = nil}

  var all: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _all ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_all = newValue}
  }
  /// Returns true if `all` has been explicitly set.
  var hasAll: Bool {return self._all != nil}
  /// Clears the value of `all`. Subsequent reads from it will return its default value.
  mutating func clearAll() {self._all = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _top: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  fileprivate var _bottom: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  fileprivate var _left: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  fileprivate var _right: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
  fileprivate var _all: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
}

struct ZPDependency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var segmentKey: String = String()

  var heightPercent: Float = 0

  var widthPercent: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionKey: String = String()

  var uiActionType: ZPActionType = .none

  var navigations: [ZPNavigation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPNavigation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///Make it as UUID
  var destinationID: String = String()

  var navigationKey: String = String()

  var transitionType: ZPNavigation.ZPTransitionType = .push

  var arguments: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPTransitionType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case push // = 0
    case present // = 1
    case backward // = 2
    case root // = 3
    case search // = 4
    case actionSheet // = 5
    case imagePicker // = 6
    case documentPicker // = 7
    case liveCameraPicker // = 8
    case liveVideoPicker // = 9
    case audioPreview // = 10
    case videoPreview // = 11
    case imagePreview // = 12
    case documentPreview // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .push
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .push
      case 1: self = .present
      case 2: self = .backward
      case 3: self = .root
      case 4: self = .search
      case 5: self = .actionSheet
      case 6: self = .imagePicker
      case 7: self = .documentPicker
      case 8: self = .liveCameraPicker
      case 9: self = .liveVideoPicker
      case 10: self = .audioPreview
      case 11: self = .videoPreview
      case 12: self = .imagePreview
      case 13: self = .documentPreview
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .push: return 0
      case .present: return 1
      case .backward: return 2
      case .root: return 3
      case .search: return 4
      case .actionSheet: return 5
      case .imagePicker: return 6
      case .documentPicker: return 7
      case .liveCameraPicker: return 8
      case .liveVideoPicker: return 9
      case .audioPreview: return 10
      case .videoPreview: return 11
      case .imagePreview: return 12
      case .documentPreview: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ZPNavigation.ZPTransitionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPNavigation.ZPTransitionType] = [
    .push,
    .present,
    .backward,
    .root,
    .search,
    .actionSheet,
    .imagePicker,
    .documentPicker,
    .liveCameraPicker,
    .liveVideoPicker,
    .audioPreview,
    .videoPreview,
    .imagePreview,
    .documentPreview,
  ]
}

#endif  // swift(>=4.2)

struct ZPItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var itemType: ZPItemType = .hStack

  var style: ZPItemStyle {
    get {return _style ?? ZPItemStyle()}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var itemSizeAttribute: ZPSizeAttribute {
    get {return _itemSizeAttribute ?? ZPSizeAttribute()}
    set {_itemSizeAttribute = newValue}
  }
  /// Returns true if `itemSizeAttribute` has been explicitly set.
  var hasItemSizeAttribute: Bool {return self._itemSizeAttribute != nil}
  /// Clears the value of `itemSizeAttribute`. Subsequent reads from it will return its default value.
  mutating func clearItemSizeAttribute() {self._itemSizeAttribute = nil}

  var actions: [ZPAction] = []

  var items: [ZPItem] = []

  var input: ZPItemInput {
    get {return _input ?? ZPItemInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var animation: ZPAnimation {
    get {return _animation ?? ZPAnimation()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  mutating func clearAnimation() {self._animation = nil}

  ////TO DO: Fix this case later (Item should not have screen id's)
  var screenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _style: ZPItemStyle? = nil
  fileprivate var _itemSizeAttribute: ZPSizeAttribute? = nil
  fileprivate var _input: ZPItemInput? = nil
  fileprivate var _animation: ZPAnimation? = nil
}

struct ZPItemInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var placeholder: String = String()

  var returnType: String = String()

  var inputType: ZPInputType = .text

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPAnimation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var animationType: ZPAnimation.ZPAnimationType = .none

  var duration: String = String()

  var distanceValue: Float = 0

  var distanceDependency: ZPDependency {
    get {return _distanceDependency ?? ZPDependency()}
    set {_distanceDependency = newValue}
  }
  /// Returns true if `distanceDependency` has been explicitly set.
  var hasDistanceDependency: Bool {return self._distanceDependency != nil}
  /// Clears the value of `distanceDependency`. Subsequent reads from it will return its default value.
  mutating func clearDistanceDependency() {self._distanceDependency = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPAnimationType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case collapse // = 1
    case fade // = 2
    case drag // = 3
    case tap // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .collapse
      case 2: self = .fade
      case 3: self = .drag
      case 4: self = .tap
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .collapse: return 1
      case .fade: return 2
      case .drag: return 3
      case .tap: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _distanceDependency: ZPDependency? = nil
}

#if swift(>=4.2)

extension ZPAnimation.ZPAnimationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPAnimation.ZPAnimationType] = [
    .none,
    .collapse,
    .fade,
    .drag,
    .tap,
  ]
}

#endif  // swift(>=4.2)

struct ZPColorRGB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var colorUid: String = String()

  var r: Int32 = 0

  var g: Int32 = 0

  var b: Int32 = 0

  var a: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ZPFontStyle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fontStyleUid: String = String()

  var fontName: String = String()

  var fontSize: Int32 = 0

  var fontWeight: ZPFontStyle.ZPFontWeightType = .ultraLight

  var textColorID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ZPFontWeightType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ultraLight // = 0
    case thin // = 1
    case light // = 2
    case regular // = 3
    case medium // = 4
    case semibold // = 5
    case bold // = 6
    case heavy // = 7
    case black // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .ultraLight
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ultraLight
      case 1: self = .thin
      case 2: self = .light
      case 3: self = .regular
      case 4: self = .medium
      case 5: self = .semibold
      case 6: self = .bold
      case 7: self = .heavy
      case 8: self = .black
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .ultraLight: return 0
      case .thin: return 1
      case .light: return 2
      case .regular: return 3
      case .medium: return 4
      case .semibold: return 5
      case .bold: return 6
      case .heavy: return 7
      case .black: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ZPFontStyle.ZPFontWeightType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ZPFontStyle.ZPFontWeightType] = [
    .ultraLight,
    .thin,
    .light,
    .regular,
    .medium,
    .semibold,
    .bold,
    .heavy,
    .black,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ZPScreenType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "list"),
    1: .same(proto: "grid"),
    2: .same(proto: "detail"),
    3: .same(proto: "reply"),
    4: .same(proto: "editList"),
    5: .same(proto: "chat"),
    6: .same(proto: "actionSheet"),
  ]
}

extension ZPDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "horizontal"),
    1: .same(proto: "vertical"),
  ]
}

extension ZPActionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "passOn"),
    2: .same(proto: "tap"),
    3: .same(proto: "longPress"),
    4: .same(proto: "leftSwipe"),
    5: .same(proto: "rightSwipe"),
    6: .same(proto: "doubleTap"),
    7: .same(proto: "onTextChange"),
  ]
}

extension ZPItemType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "hStack"),
    1: .same(proto: "vStack"),
    2: .same(proto: "zStack"),
    3: .same(proto: "label"),
    4: .same(proto: "button"),
    5: .same(proto: "textInput"),
    6: .same(proto: "textView"),
    7: .same(proto: "iconView"),
    8: .same(proto: "imageView"),
    9: .same(proto: "seperatorView"),
    10: .same(proto: "webView"),
    11: .same(proto: "scrollView"),
    12: .same(proto: "gridView"),
    13: .same(proto: "chipView"),
    14: .same(proto: "popUpView"),
    15: .same(proto: "progressView"),
    16: .same(proto: "checkBoxView"),
    17: .same(proto: "chartView"),
    18: .same(proto: "tabLayoutViewPager"),
    19: .same(proto: "pagingView"),
    20: .same(proto: "page"),
    21: .same(proto: "tabView"),
    22: .same(proto: "tabViewIndicator"),
    23: .same(proto: "listView"),
    24: .same(proto: "loader"),
    25: .same(proto: "rightBarButton"),
    26: .same(proto: "leftBarButton"),
  ]
}

extension ZPInputType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "text"),
    1: .same(proto: "number"),
    2: .same(proto: "email"),
    3: .same(proto: "web"),
    4: .same(proto: "datePicker"),
    5: .same(proto: "dateTimePicker"),
    6: .same(proto: "picker"),
    7: .same(proto: "phone"),
  ]
}

extension ZPApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screens"),
    2: .same(proto: "darkColors"),
    3: .same(proto: "lightColors"),
    4: .same(proto: "fontStyles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.screens) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.darkColors) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.lightColors) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fontStyles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.screens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.screens, fieldNumber: 1)
    }
    if !self.darkColors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.darkColors, fieldNumber: 2)
    }
    if !self.lightColors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lightColors, fieldNumber: 3)
    }
    if !self.fontStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fontStyles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPApp, rhs: ZPApp) -> Bool {
    if lhs.screens != rhs.screens {return false}
    if lhs.darkColors != rhs.darkColors {return false}
    if lhs.lightColors != rhs.lightColors {return false}
    if lhs.fontStyles != rhs.fontStyles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPScreen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPScreen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "module"),
    3: .same(proto: "screenType"),
    4: .same(proto: "segments"),
    5: .same(proto: "passOnAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.module) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.screenType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._passOnAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.module.isEmpty {
      try visitor.visitSingularStringField(value: self.module, fieldNumber: 2)
    }
    if self.screenType != .list {
      try visitor.visitSingularEnumField(value: self.screenType, fieldNumber: 3)
    }
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 4)
    }
    if let v = self._passOnAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPScreen, rhs: ZPScreen) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.module != rhs.module {return false}
    if lhs.screenType != rhs.screenType {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs._passOnAction != rhs._passOnAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "segmentType"),
    2: .same(proto: "style"),
    3: .same(proto: "segmentSizeAttribute"),
    4: .same(proto: "actions"),
    5: .same(proto: "patterns"),
    6: .same(proto: "isNative"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.segmentType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._segmentSizeAttribute) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.patterns) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isNative) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.segmentType != .topNavigationBar {
      try visitor.visitSingularEnumField(value: self.segmentType, fieldNumber: 1)
    }
    if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._segmentSizeAttribute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 4)
    }
    if !self.patterns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patterns, fieldNumber: 5)
    }
    if self.isNative != false {
      try visitor.visitSingularBoolField(value: self.isNative, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPSegment, rhs: ZPSegment) -> Bool {
    if lhs.segmentType != rhs.segmentType {return false}
    if lhs._style != rhs._style {return false}
    if lhs._segmentSizeAttribute != rhs._segmentSizeAttribute {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.patterns != rhs.patterns {return false}
    if lhs.isNative != rhs.isNative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPSegment.ZPSegmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "topNavigationBar"),
    1: .same(proto: "bottomNavigationBar"),
    2: .same(proto: "listHeader"),
    3: .same(proto: "listFooter"),
    4: .same(proto: "sectionHeader"),
    5: .same(proto: "sectionFooter"),
    6: .same(proto: "listItem"),
    7: .same(proto: "container"),
    8: .same(proto: "search"),
    9: .same(proto: "keyboardAccessoryView"),
  ]
}

extension ZPItemStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPItemStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isHide"),
    2: .standard(proto: "bgColor_id"),
    3: .same(proto: "imageStyle"),
    4: .same(proto: "gradientStyle"),
    5: .same(proto: "shadowStyle"),
    6: .same(proto: "borderStyle"),
    7: .same(proto: "gridStyle"),
    8: .same(proto: "scrollStyle"),
    9: .same(proto: "textStyle"),
    10: .same(proto: "seperatorType"),
    11: .same(proto: "tabViewType"),
    12: .same(proto: "cornerRadius"),
  ]

  fileprivate class _StorageClass {
    var _isHide: Bool = false
    var _bgColorID: String = String()
    var _imageStyle: ZPImageStyle? = nil
    var _gradientStyle: ZPGradientStyle? = nil
    var _shadowStyle: ZPShadowStyle? = nil
    var _borderStyle: ZPBorderStyle? = nil
    var _gridStyle: ZPGridStyle? = nil
    var _scrollStyle: ZPScrollStyle? = nil
    var _textStyle: ZPTextStyle? = nil
    var _seperatorType: ZPItemStyle.ZPSeparatorType = .line
    var _tabViewType: ZPItemStyle.ZPTabViewType = .segment
    var _cornerRadius: ZPItemStyle.ZPItemCornerRadius? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _isHide = source._isHide
      _bgColorID = source._bgColorID
      _imageStyle = source._imageStyle
      _gradientStyle = source._gradientStyle
      _shadowStyle = source._shadowStyle
      _borderStyle = source._borderStyle
      _gridStyle = source._gridStyle
      _scrollStyle = source._scrollStyle
      _textStyle = source._textStyle
      _seperatorType = source._seperatorType
      _tabViewType = source._tabViewType
      _cornerRadius = source._cornerRadius
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._isHide) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._bgColorID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._imageStyle) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._gradientStyle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._shadowStyle) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._borderStyle) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._gridStyle) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scrollStyle) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._textStyle) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._seperatorType) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._tabViewType) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._cornerRadius) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._isHide != false {
        try visitor.visitSingularBoolField(value: _storage._isHide, fieldNumber: 1)
      }
      if !_storage._bgColorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bgColorID, fieldNumber: 2)
      }
      if let v = _storage._imageStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._gradientStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._shadowStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._borderStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._gridStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._scrollStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._textStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._seperatorType != .line {
        try visitor.visitSingularEnumField(value: _storage._seperatorType, fieldNumber: 10)
      }
      if _storage._tabViewType != .segment {
        try visitor.visitSingularEnumField(value: _storage._tabViewType, fieldNumber: 11)
      }
      if let v = _storage._cornerRadius {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPItemStyle, rhs: ZPItemStyle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._isHide != rhs_storage._isHide {return false}
        if _storage._bgColorID != rhs_storage._bgColorID {return false}
        if _storage._imageStyle != rhs_storage._imageStyle {return false}
        if _storage._gradientStyle != rhs_storage._gradientStyle {return false}
        if _storage._shadowStyle != rhs_storage._shadowStyle {return false}
        if _storage._borderStyle != rhs_storage._borderStyle {return false}
        if _storage._gridStyle != rhs_storage._gridStyle {return false}
        if _storage._scrollStyle != rhs_storage._scrollStyle {return false}
        if _storage._textStyle != rhs_storage._textStyle {return false}
        if _storage._seperatorType != rhs_storage._seperatorType {return false}
        if _storage._tabViewType != rhs_storage._tabViewType {return false}
        if _storage._cornerRadius != rhs_storage._cornerRadius {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPItemStyle.ZPSeparatorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "line"),
    1: .same(proto: "dot"),
    2: .same(proto: "space"),
    3: .same(proto: "dashed"),
  ]
}

extension ZPItemStyle.ZPTabViewType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "segment"),
    1: .same(proto: "tab"),
  ]
}

extension ZPItemStyle.ZPItemCornerRadius: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ZPItemStyle.protoMessageName + ".ZPItemCornerRadius"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "all"),
    2: .same(proto: "topLeft"),
    3: .same(proto: "topRight"),
    4: .same(proto: "bottomLeft"),
    5: .same(proto: "bottomRight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._all) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._topLeft) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._topRight) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bottomLeft) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bottomRight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._all {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._topLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._topRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._bottomLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._bottomRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPItemStyle.ZPItemCornerRadius, rhs: ZPItemStyle.ZPItemCornerRadius) -> Bool {
    if lhs._all != rhs._all {return false}
    if lhs._topLeft != rhs._topLeft {return false}
    if lhs._topRight != rhs._topRight {return false}
    if lhs._bottomLeft != rhs._bottomLeft {return false}
    if lhs._bottomRight != rhs._bottomRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPImageStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPImageStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imagePath"),
    2: .same(proto: "fetchType"),
    3: .same(proto: "contentType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imagePath) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.fetchType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePath, fieldNumber: 1)
    }
    if self.fetchType != .urlType {
      try visitor.visitSingularEnumField(value: self.fetchType, fieldNumber: 2)
    }
    if self.contentType != .fill {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPImageStyle, rhs: ZPImageStyle) -> Bool {
    if lhs.imagePath != rhs.imagePath {return false}
    if lhs.fetchType != rhs.fetchType {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPImageStyle.ZPImageFetchType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "urlType"),
    1: .same(proto: "stream"),
  ]
}

extension ZPImageStyle.ZPImageContentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "fill"),
    1: .same(proto: "contain"),
    2: .same(proto: "cover"),
    3: .same(proto: "center"),
  ]
}

extension ZPGradientStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPGradientStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "color_id"),
    2: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.colorID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.colorID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.colorID, fieldNumber: 1)
    }
    if self.direction != .horizontal {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPGradientStyle, rhs: ZPGradientStyle) -> Bool {
    if lhs.colorID != rhs.colorID {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPShadowStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPShadowStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shadowColor_id"),
    2: .same(proto: "shadowRadius"),
    3: .same(proto: "shadowOpacity"),
    4: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shadowColorID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.shadowRadius) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.shadowOpacity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shadowColorID.isEmpty {
      try visitor.visitSingularStringField(value: self.shadowColorID, fieldNumber: 1)
    }
    if self.shadowRadius != 0 {
      try visitor.visitSingularInt32Field(value: self.shadowRadius, fieldNumber: 2)
    }
    if self.shadowOpacity != 0 {
      try visitor.visitSingularFloatField(value: self.shadowOpacity, fieldNumber: 3)
    }
    if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPShadowStyle, rhs: ZPShadowStyle) -> Bool {
    if lhs.shadowColorID != rhs.shadowColorID {return false}
    if lhs.shadowRadius != rhs.shadowRadius {return false}
    if lhs.shadowOpacity != rhs.shadowOpacity {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPShadowStyle.ZPShadowOffset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ZPShadowStyle.protoMessageName + ".ZPShadowOffset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPShadowStyle.ZPShadowOffset, rhs: ZPShadowStyle.ZPShadowOffset) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPBorderStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPBorderStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "borderColor_id"),
    2: .same(proto: "borderWidth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.borderColorID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.borderWidth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.borderColorID.isEmpty {
      try visitor.visitSingularStringField(value: self.borderColorID, fieldNumber: 1)
    }
    if self.borderWidth != 0 {
      try visitor.visitSingularFloatField(value: self.borderWidth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPBorderStyle, rhs: ZPBorderStyle) -> Bool {
    if lhs.borderColorID != rhs.borderColorID {return false}
    if lhs.borderWidth != rhs.borderWidth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPGridStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPGridStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isDraggable"),
    2: .same(proto: "gridColoumnCount"),
    3: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isDraggable) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gridColoumnCount) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isDraggable != false {
      try visitor.visitSingularBoolField(value: self.isDraggable, fieldNumber: 1)
    }
    if let v = self._gridColoumnCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.direction != .horizontal {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPGridStyle, rhs: ZPGridStyle) -> Bool {
    if lhs.isDraggable != rhs.isDraggable {return false}
    if lhs._gridColoumnCount != rhs._gridColoumnCount {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPScrollStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPScrollStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isShowHorizontalScrollIndicator"),
    2: .same(proto: "isShowVerticalScrollIndicator"),
    3: .same(proto: "isScrollEnabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isShowHorizontalScrollIndicator) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isShowVerticalScrollIndicator) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isScrollEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isShowHorizontalScrollIndicator != false {
      try visitor.visitSingularBoolField(value: self.isShowHorizontalScrollIndicator, fieldNumber: 1)
    }
    if self.isShowVerticalScrollIndicator != false {
      try visitor.visitSingularBoolField(value: self.isShowVerticalScrollIndicator, fieldNumber: 2)
    }
    if self.isScrollEnabled != false {
      try visitor.visitSingularBoolField(value: self.isScrollEnabled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPScrollStyle, rhs: ZPScrollStyle) -> Bool {
    if lhs.isShowHorizontalScrollIndicator != rhs.isShowHorizontalScrollIndicator {return false}
    if lhs.isShowVerticalScrollIndicator != rhs.isShowVerticalScrollIndicator {return false}
    if lhs.isScrollEnabled != rhs.isScrollEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPTextStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPTextStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fontStyle_id"),
    2: .same(proto: "isEditable"),
    3: .same(proto: "maxLines"),
    4: .same(proto: "alignment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fontStyleID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isEditable) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxLines) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.alignment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fontStyleID.isEmpty {
      try visitor.visitSingularStringField(value: self.fontStyleID, fieldNumber: 1)
    }
    if self.isEditable != false {
      try visitor.visitSingularBoolField(value: self.isEditable, fieldNumber: 2)
    }
    if self.maxLines != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLines, fieldNumber: 3)
    }
    if self.alignment != .left {
      try visitor.visitSingularEnumField(value: self.alignment, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPTextStyle, rhs: ZPTextStyle) -> Bool {
    if lhs.fontStyleID != rhs.fontStyleID {return false}
    if lhs.isEditable != rhs.isEditable {return false}
    if lhs.maxLines != rhs.maxLines {return false}
    if lhs.alignment != rhs.alignment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPTextStyle.ZPTextAlignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "left"),
    1: .same(proto: "right"),
    2: .same(proto: "top"),
    3: .same(proto: "bottom"),
    4: .same(proto: "center"),
    5: .same(proto: "justified"),
    6: .same(proto: "natural"),
  ]
}

extension ZPSizeAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPSizeAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "minWidth"),
    4: .same(proto: "huggingPriority"),
    5: .same(proto: "resistentPriority"),
    6: .same(proto: "depency"),
    7: .same(proto: "padding"),
    8: .same(proto: "position"),
  ]

  fileprivate class _StorageClass {
    var _width: ZPSize? = nil
    var _height: ZPSize? = nil
    var _minWidth: ZPSize? = nil
    var _huggingPriority: String = String()
    var _resistentPriority: String = String()
    var _depency: ZPDependency? = nil
    var _padding: ZPPadding? = nil
    var _position: ZPSizeAttribute.ZPZStackPosition = .none

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _width = source._width
      _height = source._height
      _minWidth = source._minWidth
      _huggingPriority = source._huggingPriority
      _resistentPriority = source._resistentPriority
      _depency = source._depency
      _padding = source._padding
      _position = source._position
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._width) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._height) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._minWidth) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._huggingPriority) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._resistentPriority) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._depency) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._padding) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._position) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._width {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._height {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._minWidth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._huggingPriority.isEmpty {
        try visitor.visitSingularStringField(value: _storage._huggingPriority, fieldNumber: 4)
      }
      if !_storage._resistentPriority.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resistentPriority, fieldNumber: 5)
      }
      if let v = _storage._depency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._padding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._position != .none {
        try visitor.visitSingularEnumField(value: _storage._position, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPSizeAttribute, rhs: ZPSizeAttribute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._minWidth != rhs_storage._minWidth {return false}
        if _storage._huggingPriority != rhs_storage._huggingPriority {return false}
        if _storage._resistentPriority != rhs_storage._resistentPriority {return false}
        if _storage._depency != rhs_storage._depency {return false}
        if _storage._padding != rhs_storage._padding {return false}
        if _storage._position != rhs_storage._position {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPSizeAttribute.ZPZStackPosition: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "center"),
    2: .same(proto: "topLeft"),
    3: .same(proto: "topRight"),
    4: .same(proto: "bottomLeft"),
    5: .same(proto: "bottomRight"),
    6: .same(proto: "topCenter"),
    7: .same(proto: "bottomCenter"),
    8: .same(proto: "leftCenter"),
    9: .same(proto: "rightCenter"),
  ]
}

extension ZPSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPSize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valueType"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.valueType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valueType != .none {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPSize, rhs: ZPSize) -> Bool {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPSize.ZPSizeValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "stretchToParent"),
    2: .same(proto: "wrapContent"),
    3: .same(proto: "staticValue"),
  ]
}

extension ZPPadding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPPadding"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "top"),
    2: .same(proto: "bottom"),
    3: .same(proto: "left"),
    4: .same(proto: "right"),
    5: .same(proto: "all"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._top) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bottom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._left) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._right) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._all) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._top {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._bottom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._left {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._right {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._all {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPPadding, rhs: ZPPadding) -> Bool {
    if lhs._top != rhs._top {return false}
    if lhs._bottom != rhs._bottom {return false}
    if lhs._left != rhs._left {return false}
    if lhs._right != rhs._right {return false}
    if lhs._all != rhs._all {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPDependency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPDependency"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "segmentKey"),
    2: .same(proto: "heightPercent"),
    3: .same(proto: "widthPercent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.segmentKey) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.heightPercent) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.widthPercent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segmentKey.isEmpty {
      try visitor.visitSingularStringField(value: self.segmentKey, fieldNumber: 1)
    }
    if self.heightPercent != 0 {
      try visitor.visitSingularFloatField(value: self.heightPercent, fieldNumber: 2)
    }
    if self.widthPercent != 0 {
      try visitor.visitSingularFloatField(value: self.widthPercent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPDependency, rhs: ZPDependency) -> Bool {
    if lhs.segmentKey != rhs.segmentKey {return false}
    if lhs.heightPercent != rhs.heightPercent {return false}
    if lhs.widthPercent != rhs.widthPercent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionKey"),
    2: .same(proto: "uiActionType"),
    3: .same(proto: "navigations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.uiActionType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.navigations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.actionKey, fieldNumber: 1)
    }
    if self.uiActionType != .none {
      try visitor.visitSingularEnumField(value: self.uiActionType, fieldNumber: 2)
    }
    if !self.navigations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.navigations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPAction, rhs: ZPAction) -> Bool {
    if lhs.actionKey != rhs.actionKey {return false}
    if lhs.uiActionType != rhs.uiActionType {return false}
    if lhs.navigations != rhs.navigations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPNavigation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPNavigation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "destination_id"),
    2: .same(proto: "navigationKey"),
    3: .same(proto: "transitionType"),
    4: .same(proto: "arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destinationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.navigationKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.transitionType) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destinationID.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationID, fieldNumber: 1)
    }
    if !self.navigationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.navigationKey, fieldNumber: 2)
    }
    if self.transitionType != .push {
      try visitor.visitSingularEnumField(value: self.transitionType, fieldNumber: 3)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPNavigation, rhs: ZPNavigation) -> Bool {
    if lhs.destinationID != rhs.destinationID {return false}
    if lhs.navigationKey != rhs.navigationKey {return false}
    if lhs.transitionType != rhs.transitionType {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPNavigation.ZPTransitionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "push"),
    1: .same(proto: "present"),
    2: .same(proto: "backward"),
    3: .same(proto: "root"),
    4: .same(proto: "search"),
    5: .same(proto: "actionSheet"),
    6: .same(proto: "imagePicker"),
    7: .same(proto: "documentPicker"),
    8: .same(proto: "liveCameraPicker"),
    9: .same(proto: "liveVideoPicker"),
    10: .same(proto: "audioPreview"),
    11: .same(proto: "videoPreview"),
    12: .same(proto: "imagePreview"),
    13: .same(proto: "documentPreview"),
  ]
}

extension ZPItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "itemType"),
    3: .same(proto: "style"),
    4: .same(proto: "itemSizeAttribute"),
    5: .same(proto: "actions"),
    6: .same(proto: "items"),
    7: .same(proto: "input"),
    8: .same(proto: "animation"),
    9: .same(proto: "screenId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._itemSizeAttribute) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.screenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.itemType != .hStack {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 2)
    }
    if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._itemSizeAttribute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 5)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 6)
    }
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.screenID.isEmpty {
      try visitor.visitSingularStringField(value: self.screenID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPItem, rhs: ZPItem) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.itemType != rhs.itemType {return false}
    if lhs._style != rhs._style {return false}
    if lhs._itemSizeAttribute != rhs._itemSizeAttribute {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.items != rhs.items {return false}
    if lhs._input != rhs._input {return false}
    if lhs._animation != rhs._animation {return false}
    if lhs.screenID != rhs.screenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPItemInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPItemInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "placeholder"),
    2: .same(proto: "returnType"),
    3: .same(proto: "inputType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.placeholder) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.returnType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.inputType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.placeholder.isEmpty {
      try visitor.visitSingularStringField(value: self.placeholder, fieldNumber: 1)
    }
    if !self.returnType.isEmpty {
      try visitor.visitSingularStringField(value: self.returnType, fieldNumber: 2)
    }
    if self.inputType != .text {
      try visitor.visitSingularEnumField(value: self.inputType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPItemInput, rhs: ZPItemInput) -> Bool {
    if lhs.placeholder != rhs.placeholder {return false}
    if lhs.returnType != rhs.returnType {return false}
    if lhs.inputType != rhs.inputType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPAnimation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPAnimation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "animationType"),
    2: .same(proto: "duration"),
    3: .same(proto: "distanceValue"),
    4: .same(proto: "distanceDependency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.animationType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.distanceValue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._distanceDependency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.animationType != .none {
      try visitor.visitSingularEnumField(value: self.animationType, fieldNumber: 1)
    }
    if !self.duration.isEmpty {
      try visitor.visitSingularStringField(value: self.duration, fieldNumber: 2)
    }
    if self.distanceValue != 0 {
      try visitor.visitSingularFloatField(value: self.distanceValue, fieldNumber: 3)
    }
    if let v = self._distanceDependency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPAnimation, rhs: ZPAnimation) -> Bool {
    if lhs.animationType != rhs.animationType {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.distanceValue != rhs.distanceValue {return false}
    if lhs._distanceDependency != rhs._distanceDependency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPAnimation.ZPAnimationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "collapse"),
    2: .same(proto: "fade"),
    3: .same(proto: "drag"),
    4: .same(proto: "tap"),
  ]
}

extension ZPColorRGB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPColorRGB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "color_uid"),
    2: .same(proto: "r"),
    3: .same(proto: "g"),
    4: .same(proto: "b"),
    5: .same(proto: "a"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.colorUid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.r) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.g) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.b) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.a) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.colorUid.isEmpty {
      try visitor.visitSingularStringField(value: self.colorUid, fieldNumber: 1)
    }
    if self.r != 0 {
      try visitor.visitSingularInt32Field(value: self.r, fieldNumber: 2)
    }
    if self.g != 0 {
      try visitor.visitSingularInt32Field(value: self.g, fieldNumber: 3)
    }
    if self.b != 0 {
      try visitor.visitSingularInt32Field(value: self.b, fieldNumber: 4)
    }
    if self.a != 0 {
      try visitor.visitSingularFloatField(value: self.a, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPColorRGB, rhs: ZPColorRGB) -> Bool {
    if lhs.colorUid != rhs.colorUid {return false}
    if lhs.r != rhs.r {return false}
    if lhs.g != rhs.g {return false}
    if lhs.b != rhs.b {return false}
    if lhs.a != rhs.a {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPFontStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ZPFontStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fontStyle_uid"),
    2: .standard(proto: "font_name"),
    3: .standard(proto: "font_size"),
    4: .standard(proto: "font_weight"),
    5: .standard(proto: "textColor_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fontStyleUid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fontName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.fontSize) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.fontWeight) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.textColorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fontStyleUid.isEmpty {
      try visitor.visitSingularStringField(value: self.fontStyleUid, fieldNumber: 1)
    }
    if !self.fontName.isEmpty {
      try visitor.visitSingularStringField(value: self.fontName, fieldNumber: 2)
    }
    if self.fontSize != 0 {
      try visitor.visitSingularInt32Field(value: self.fontSize, fieldNumber: 3)
    }
    if self.fontWeight != .ultraLight {
      try visitor.visitSingularEnumField(value: self.fontWeight, fieldNumber: 4)
    }
    if !self.textColorID.isEmpty {
      try visitor.visitSingularStringField(value: self.textColorID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ZPFontStyle, rhs: ZPFontStyle) -> Bool {
    if lhs.fontStyleUid != rhs.fontStyleUid {return false}
    if lhs.fontName != rhs.fontName {return false}
    if lhs.fontSize != rhs.fontSize {return false}
    if lhs.fontWeight != rhs.fontWeight {return false}
    if lhs.textColorID != rhs.textColorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ZPFontStyle.ZPFontWeightType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ultraLight"),
    1: .same(proto: "thin"),
    2: .same(proto: "light"),
    3: .same(proto: "regular"),
    4: .same(proto: "medium"),
    5: .same(proto: "semibold"),
    6: .same(proto: "bold"),
    7: .same(proto: "heavy"),
    8: .same(proto: "black"),
  ]
}
